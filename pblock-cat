#!/usr/bin/env python

import argparse
import logging
import pblock
import sys


parser = argparse.ArgumentParser(description="Read pblock connection until first unset space.")
parser.add_argument(
    "-o", "--output",
    dest='output', default=sys.stdout.buffer, type=argparse.FileType('wb'),
    help="where to print received data (dafult stdout)",
)
parser.add_argument(
    "-s", "--offset",
    dest='offset', default=0, type=int,
    help="offset (in bytes) to start reading at",
)
parser.add_argument(
    "-c", "--count",
    dest='count', default=-1, type=int,
    help="read at most this many bytes",
)
parser.add_argument(
    "-b", "--block-size",
    dest='block_size', default=4096, type=int,
    help="request blocks of this size (default 4096)",
)
parser.add_argument(
    "-r", "--reading-stream",
    dest='reading_stream', default=3, type=str,
    help="stream for reading from server, when numeric it's treated as fd (default fd 3)",
)
parser.add_argument(
    "-w", "--writing-stream",
    dest='writing_stream', default=3, type=str,
    help="stream for writing to server, when numeric it's treated as fd (default fd 3)",
)
parser.add_argument(
    "-v", "--verbose",
    dest='verbose_count', action='count', default=0,
    help="increases log verbosity for each occurence",
)

if __name__ == '__main__':
    arguments = parser.parse_args()

    # Sets log level to WARN going more verbose for each new -v.
    logging.basicConfig(
        format='%(levelname)s: %(message)s',
        level=max(3 - arguments.verbose_count, 0) * 10,
    )

    logging.info("pblock-cat running with commandline {}".format(sys.argv))

    connection = pblock.ConnectionToServer.open(
        arguments.reading_stream,
        arguments.writing_stream,
    )

    offset = arguments.offset
    while arguments.count < 0 or offset < arguments.offset + arguments.count:
        old_offset = offset

        # request transfer
        to_read = arguments.block_size
        if arguments.count >= 0:
            to_read = min(
                to_read,
                arguments.offset + arguments.count - offset,
            )
        pblock.Transaction([
            pblock.Segment.read_request(offset, to_read),
        ]).write_to_stream(connection.writing_stream)
        connection.writing_stream.flush()
        logging.debug("request for data sent (offset {}, length {})".format(
            offset, arguments.block_size,
        ))

        # receive response
        t = pblock.Transaction.from_stream(connection.reading_stream)
        logging.debug("received incoming transaction ({} segments)".format(len(t.segments)))
        if len(t.segments) == 0:
            # no data in this range
            logging.info("exiting due to empty incoming transaction")
            sys.exit()

        for segment in sorted(t.segments, key=lambda s: s.offset):
            if segment.type == pblock.SegmentType.WRITE:
                logging.debug("received data segment (offset {}, length {})".format(
                    segment.offset, segment.length,
                ))
                if segment.offset != offset:
                    # received data after a hole in a file
                    logging.info("exiting due to difference in received offset ({}) and our offset ({})".format(
                        segment.offset, offset,
                    ))
                    sys.exit()
                arguments.output.write(segment.payload)
                offset += segment.length
            else:
                logging.warning("received segment of unsupported type ({})".format(
                    segment,
                ))

        if old_offset == offset:
            logging.info("exiting because no advance in reading was made")
            sys.exit()
